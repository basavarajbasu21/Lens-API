'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Amount = require('./Amount-f03e19a2.cjs.dev.js');
var defaultTo = require('lodash/defaultTo.js');
var isObject = require('lodash/isObject.js');
var lodashGet = require('lodash/get.js');
var uuid = require('uuid');
var isObjectLike = require('lodash/isObjectLike.js');
require('decimal.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var defaultTo__default = /*#__PURE__*/_interopDefault(defaultTo);
var isObject__default = /*#__PURE__*/_interopDefault(isObject);
var lodashGet__default = /*#__PURE__*/_interopDefault(lodashGet);
var isObjectLike__default = /*#__PURE__*/_interopDefault(isObjectLike);

function hasAtLeastOne(items) {
  return items.length > 0;
}
function assertNonEmptyArray(items) {
  Amount.invariant(hasAtLeastOne(items), "Expected array of to have at least one item, but received 0 items");
}
function hasJustOne(items) {
  return items.length === 1;
}
function assertJustOne(items) {
  Amount.invariant(hasJustOne(items), 'Expected array of to have exactly one item.');
}
function removeAtIndex(items, index) {
  return items.slice(0, index).concat(items.slice(index + 1));
}
function hasTwoOrMore(items) {
  return items.length >= 2;
}

/**
 * This subclass of Error supports chaining.
 * If available, it uses the built-in support for property `.cause`.
 * Otherwise, it sets it up itself.
 *
 * @see https://github.com/tc39/proposal-error-cause
 * @internal
 */
var CausedError = /*#__PURE__*/function (_Error) {
  Amount._inherits(CausedError, _Error);
  var _super = Amount._createSuper(CausedError);
  function CausedError(message, options) {
    var _this;
    Amount._classCallCheck(this, CausedError);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore Error not yet properly typed
    _this = _super.call(this, message, options);
    if (isObject__default["default"](options) && 'cause' in options && !('cause' in Amount._assertThisInitialized(_this))) {
      var cause = options.cause;
      _this.cause = cause;
      if (typeof cause.stack === 'string') {
        _this.stack = defaultTo__default["default"](_this.stack, '') + '\nCAUSE: ' + cause.stack;
      }
    }
    return _this;
  }
  return Amount._createClass(CausedError);
}( /*#__PURE__*/Amount._wrapNativeSuper(Error));

/**
 * Represent number of milliseconds since the Unix Epoch
 */

var DateUtils = /*#__PURE__*/function () {
  function DateUtils() {
    Amount._classCallCheck(this, DateUtils);
  }
  Amount._createClass(DateUtils, null, [{
    key: "toUnix",
    value: function toUnix(date) {
      if (date instanceof Date) {
        return date.getTime();
      }
      if (typeof date === 'string') {
        return new Date(date).getTime();
      }
      return date;
    }
  }, {
    key: "toISOString",
    value: function toISOString(date) {
      if (typeof date === 'string' || typeof date === 'number') {
        return new Date(date).toISOString();
      }
      return date.toISOString();
    }
  }, {
    key: "unix",
    value: function unix() {
      return Date.now();
    }
  }, {
    key: "unixInSeconds",
    value: function unixInSeconds() {
      return this.unix() / 1000;
    }
  }, {
    key: "hoursToMs",
    value: function hoursToMs(hours) {
      return this.minutesToMs(hours * 60);
    }
  }, {
    key: "minutesToMs",
    value: function minutesToMs(minutes) {
      return minutes * 6 * 10 * 1000;
    }
  }, {
    key: "secondsToMs",
    value: function secondsToMs(seconds) {
      return seconds * 1000;
    }
  }]);
  return DateUtils;
}();

/**
 * Inspired by https://dev.to/tipsy_dev/advanced-typescript-reinventing-lodash-get-4fhe
 */
function get(data, path, defaultValue) {
  var lodashPath = path.split('.');
  return lodashGet__default["default"](data, lodashPath, defaultValue);
}

function getID() {
  return uuid.v4();
}

/**
 * A `Success<T, E>` represents a successful computation that returns a value of type `T`.
 *
 * `E` in `Success<T, E>` is the type of the error that would have been returned in case of failure.
 * It's present only to allow type safety of the `isFailure` method.
 *
 * @sealed
 * @privateRemarks DO NOT EXPORT, see type export later on
 */
var Success = /*#__PURE__*/function () {
  /** @internal */
  function Success(value) {
    Amount._classCallCheck(this, Success);
    this.value = value;
  }
  Amount._createClass(Success, [{
    key: "isSuccess",
    value: function isSuccess() {
      return true;
    }
  }, {
    key: "isFailure",
    value: function isFailure() {
      return false;
    }
  }, {
    key: "unwrap",
    value: function unwrap() {
      return this.value;
    }
  }]);
  return Success;
}();
/**
 * A `Success<T, E>` represents a successful computation that returns a value of type `T`.
 *
 * `T` in `Failure<T, E>` is the type of the value that would have been returned in case of success.
 * It's present only to allow type safety of the `isSuccess` method.
 *
 * @sealed
 * @privateRemarks DO NOT EXPORT, see type export later on
 */
var Failure = /*#__PURE__*/function () {
  /** @internal */
  function Failure(error) {
    Amount._classCallCheck(this, Failure);
    this.error = error;
  }
  Amount._createClass(Failure, [{
    key: "isSuccess",
    value: function isSuccess() {
      return false;
    }
  }, {
    key: "isFailure",
    value: function isFailure() {
      return true;
    }
  }, {
    key: "unwrap",
    value: function unwrap() {
      throw this.error;
    }
  }]);
  return Failure;
}();
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function success() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  return new Success(value);
}
var failure = function failure(error) {
  return new Failure(error);
};

/**
 * Returns `true` if the result is a success.
 */
function assertSuccess(result) {
  Amount.invariant(result.isSuccess(), 'Expected a success result');
}

/**
 * Returns `true` if the result is a failure.
 */
function assertFailure(result) {
  Amount.invariant(result.isFailure(), 'Expected a failure result');
}

/**
 * Unwraps the promise to allow resolving/rejecting outside the Promise constructor
 */
var Deferred = /*#__PURE__*/Amount._createClass(function Deferred() {
  var _this = this;
  Amount._classCallCheck(this, Deferred);
  this.promise = new Promise(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
  });
});

var POLLING_TIME = 1000;
var lastActiveTimerId = 0;
var activeTimers = new Set();
var safeSetTimeoutRec = function safeSetTimeoutRec(fn, endTime, timerId, options) {
  var msToEnd = endTime - Date.now();
  setTimeout(function () {
    if (!activeTimers.has(timerId)) {
      return;
    }
    var now = Date.now();
    if (now >= endTime) {
      activeTimers["delete"](timerId);
      fn();
    } else {
      safeSetTimeoutRec(fn, endTime, timerId, options);
    }
  }, msToEnd <= options.poolingTimeout ? msToEnd : options.poolingTimeout);
};

/**
 * Safe version of `setTimeout` that should support
 * 1. Large milliseconds delays (larger than 2147483647)
 * 2. Hibernation/Sleep
 *
 * @param fn - callback to be invoked after
 * @param ms - milliseconds to wait
 * @param options - timer options
 *
 * Note: `safeSetTimeout` should be only used when really needed
 *        as processor overhead is bigger than with normal `setTimeout`
 * @returns timerId Use `clearSafeTimeout(timerId)` to cancel timeout
 */
var safeSetTimeout = function safeSetTimeout(fn, ms) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    poolingTimeout: POLLING_TIME
  };
  var timerId = ++lastActiveTimerId;
  activeTimers.add(timerId);
  safeSetTimeoutRec(fn, Date.now() + ms, timerId, options);
  return timerId;
};

/**
 * Cancel timeout created with `safeSetTimeout`.
 */
var clearSafeTimeout = function clearSafeTimeout(timerId) {
  activeTimers["delete"](timerId);
};

function assertError(error) {
  if (!(error instanceof Error)) {
    throw new Amount.InvariantError("Invalid error type. Received ".concat(Amount._typeof(error), ", expected instance of Error"));
  }
}
function assertErrorWithCode(error) {
  // eslint-disable-next-line no-prototype-builtins
  if (!(error instanceof Error && error.hasOwnProperty('code'))) {
    throw error;
  }
}
function assertErrorWithReason(error) {
  // eslint-disable-next-line no-prototype-builtins
  if (!(error instanceof Error && error.hasOwnProperty('reason'))) {
    throw error;
  }
}

/**
 * Exhaustiveness checking for union and enum types
 * see https://www.typescriptlang.org/docs/handbook/2/narrowing.html#exhaustiveness-checking
 */
function assertNever(x) {
  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected object: ".concat(String(x));
  throw new Amount.InvariantError(message);
}

function never() {
  var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Unexpected call to never()';
  throw new Amount.InvariantError(message);
}

/**
 *  Cast a `value` to exclude `null` and `undefined`.
 *  Throws if either `null` or `undefined` was passed
 */
function nonNullable(value, message) {
  if (value !== undefined && value !== null) {
    return value;
  }
  throw new Amount.InvariantError("Non nullable values expected, received ".concat(String(value), " with message: ").concat(message));
}
function isNonNullable(value) {
  return value !== null && value !== undefined;
}

var isInEnum = function isInEnum(enumVariables, value) {
  return Object.values(enumVariables).includes(value);
};

/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any */
function isPrimitive(value) {
  return !isObjectLike__default["default"](value);
}
function omitDeep(target, omitKey) {
  if (isPrimitive(target)) {
    return target;
  }
  if (Array.isArray(target)) {
    return target.map(function (item) {
      return omitDeep(item, omitKey);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
  return Object.keys(target).reduce(function (acc, key) {
    if (key === omitKey) {
      return acc;
    }
    var value = omitDeep(target[key], omitKey);
    acc[key] = value;
    return acc;
  }, {});
}

function maybe(thunk) {
  try {
    return thunk();
  } catch (_unused) {
    /* empty on purpose */
    return undefined;
  }
}

exports.Amount = Amount.Amount;
exports.BigDecimal = Amount.BigDecimal;
Object.defineProperty(exports, 'ChainType', {
  enumerable: true,
  get: function () { return Amount.ChainType; }
});
exports.Denomination = Amount.Denomination;
exports.InvariantError = Amount.InvariantError;
Object.defineProperty(exports, 'Kind', {
  enumerable: true,
  get: function () { return Amount.Kind; }
});
Object.defineProperty(exports, 'NativeType', {
  enumerable: true,
  get: function () { return Amount.NativeType; }
});
Object.defineProperty(exports, 'WellKnownSymbols', {
  enumerable: true,
  get: function () { return Amount.WellKnownSymbols; }
});
exports.erc20 = Amount.erc20;
exports.ether = Amount.ether;
exports.invariant = Amount.invariant;
exports.matic = Amount.matic;
exports.usd = Amount.usd;
exports.CausedError = CausedError;
exports.DateUtils = DateUtils;
exports.Deferred = Deferred;
exports.assertError = assertError;
exports.assertErrorWithCode = assertErrorWithCode;
exports.assertErrorWithReason = assertErrorWithReason;
exports.assertFailure = assertFailure;
exports.assertJustOne = assertJustOne;
exports.assertNever = assertNever;
exports.assertNonEmptyArray = assertNonEmptyArray;
exports.assertSuccess = assertSuccess;
exports.clearSafeTimeout = clearSafeTimeout;
exports.failure = failure;
exports.get = get;
exports.getID = getID;
exports.hasAtLeastOne = hasAtLeastOne;
exports.hasJustOne = hasJustOne;
exports.hasTwoOrMore = hasTwoOrMore;
exports.isInEnum = isInEnum;
exports.isNonNullable = isNonNullable;
exports.maybe = maybe;
exports.never = never;
exports.nonNullable = nonNullable;
exports.omitDeep = omitDeep;
exports.removeAtIndex = removeAtIndex;
exports.safeSetTimeout = safeSetTimeout;
exports.success = success;
