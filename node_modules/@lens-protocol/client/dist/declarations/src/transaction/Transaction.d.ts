import type { PromiseResult } from '@lens-protocol/shared-kernel';
import type { Authentication } from '../authentication';
import type { LensConfig } from '../consts/config';
import type { CredentialsExpiredError, NotAuthenticatedError } from '../consts/errors';
import type { CreateDataAvailabilityPublicationResultFragment, RelayerResultFragment, RelayErrorFragment } from '../graphql/fragments.generated';
import type { BroadcastRequest } from '../graphql/types.generated';
import { TransactionErrorFragment, TransactionIndexedResultFragment } from './graphql/transaction.generated';
export declare class TransactionPollingError extends Error {
    name: "TransactionPollingError";
    message: string;
}
/**
 * Broadcast signed typed data for a gasless transaction.
 *
 * @remarks
 *
 * Typed data is a way to try to show the users what they are signing
 * in a more readable format. You should only call transaction broadcast
 * if you are using the typed data logic.
 *
 * @group LensClient Modules
 */
export declare class Transaction {
    private readonly authentication;
    private readonly sdk;
    constructor(config: LensConfig, authentication: Authentication);
    /**
     * Broadcast a signed typed data for a gasless transaction.
     *
     * ⚠️ Requires authenticated LensClient.
     *
     * @param request - Request object for the mutation
     * @returns {@link PromiseResult} with {@link RelayerResultFragment} or {@link RelayErrorFragment}
     *
     * @example
     * ```ts
     * const result = await client.transaction.broadcast({
     *   id: data.id,
     *   signature: signedTypedData,
     * });
     * ```
     */
    broadcast(request: BroadcastRequest): PromiseResult<RelayerResultFragment | RelayErrorFragment, CredentialsExpiredError | NotAuthenticatedError>;
    /**
     * Check if a transaction has been indexed.
     *
     * ⚠️ Requires authenticated LensClient.
     *
     * @param txId - transaction id
     * @returns {@link PromiseResult} with {@link TransactionIndexedResultFragment} or {@link TransactionErrorFragment}
     *
     * @example
     * ```ts
     * const result = await client.transaction.wasIndexed(txId);
     * ```
     */
    wasIndexed(txId: string): PromiseResult<TransactionIndexedResultFragment | TransactionErrorFragment, CredentialsExpiredError | NotAuthenticatedError>;
    /**
     * Poll the transaction status until it has been indexed.
     *
     * ⚠️ Requires authenticated LensClient.
     *
     * @param txId - transaction id
     * @returns {@link PromiseResult} with {@link TransactionIndexedResultFragment} or {@link TransactionErrorFragment}
     *
     * @example
     * ```ts
     * const result = await client.transaction.waitForIsIndexed(txId);
     * ```
     */
    waitForIsIndexed(txId: string): PromiseResult<TransactionIndexedResultFragment | TransactionErrorFragment, CredentialsExpiredError | NotAuthenticatedError>;
    /**
     * Broadcast a signed typed data for a data availability publication.
     *
     * ⚠️ Requires authenticated LensClient.
     *
     * @param request - Request object for the mutation
     * @returns {@link PromiseResult} with {@link CreateDataAvailabilityPublicationResultFragment} or {@link RelayErrorFragment}
     *
     * @example
     * ```ts
     * const result = await client.transaction.broadcastDataAvailability({
     *   id: data.id,
     *   signature: signedTypedData,
     * });
     * ```
     */
    broadcastDataAvailability(request: BroadcastRequest): PromiseResult<CreateDataAvailabilityPublicationResultFragment | RelayErrorFragment, CredentialsExpiredError | NotAuthenticatedError>;
}
