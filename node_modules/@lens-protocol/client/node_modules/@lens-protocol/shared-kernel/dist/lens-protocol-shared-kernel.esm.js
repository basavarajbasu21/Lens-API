import { i as invariant, _ as _inherits, a as _createSuper, b as _classCallCheck, c as _assertThisInitialized, d as _createClass, e as _wrapNativeSuper, I as InvariantError, f as _typeof } from './Amount-fd174e4c.esm.js';
export { A as Amount, B as BigDecimal, C as ChainType, D as Denomination, I as InvariantError, K as Kind, N as NativeType, W as WellKnownSymbols, g as erc20, h as ether, i as invariant, m as matic, u as usd } from './Amount-fd174e4c.esm.js';
import defaultTo from 'lodash/defaultTo.js';
import isObject from 'lodash/isObject.js';
import lodashGet from 'lodash/get.js';
import { v4 } from 'uuid';
import isObjectLike from 'lodash/isObjectLike.js';
import 'decimal.js';

function hasAtLeastOne(items) {
  return items.length > 0;
}
function assertNonEmptyArray(items) {
  invariant(hasAtLeastOne(items), "Expected array of to have at least one item, but received 0 items");
}
function hasJustOne(items) {
  return items.length === 1;
}
function assertJustOne(items) {
  invariant(hasJustOne(items), 'Expected array of to have exactly one item.');
}
function removeAtIndex(items, index) {
  return items.slice(0, index).concat(items.slice(index + 1));
}
function hasTwoOrMore(items) {
  return items.length >= 2;
}

/**
 * This subclass of Error supports chaining.
 * If available, it uses the built-in support for property `.cause`.
 * Otherwise, it sets it up itself.
 *
 * @see https://github.com/tc39/proposal-error-cause
 * @internal
 */
var CausedError = /*#__PURE__*/function (_Error) {
  _inherits(CausedError, _Error);
  var _super = _createSuper(CausedError);
  function CausedError(message, options) {
    var _this;
    _classCallCheck(this, CausedError);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore Error not yet properly typed
    _this = _super.call(this, message, options);
    if (isObject(options) && 'cause' in options && !('cause' in _assertThisInitialized(_this))) {
      var cause = options.cause;
      _this.cause = cause;
      if (typeof cause.stack === 'string') {
        _this.stack = defaultTo(_this.stack, '') + '\nCAUSE: ' + cause.stack;
      }
    }
    return _this;
  }
  return _createClass(CausedError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

/**
 * Represent number of milliseconds since the Unix Epoch
 */

var DateUtils = /*#__PURE__*/function () {
  function DateUtils() {
    _classCallCheck(this, DateUtils);
  }
  _createClass(DateUtils, null, [{
    key: "toUnix",
    value: function toUnix(date) {
      if (date instanceof Date) {
        return date.getTime();
      }
      if (typeof date === 'string') {
        return new Date(date).getTime();
      }
      return date;
    }
  }, {
    key: "toISOString",
    value: function toISOString(date) {
      if (typeof date === 'string' || typeof date === 'number') {
        return new Date(date).toISOString();
      }
      return date.toISOString();
    }
  }, {
    key: "unix",
    value: function unix() {
      return Date.now();
    }
  }, {
    key: "unixInSeconds",
    value: function unixInSeconds() {
      return this.unix() / 1000;
    }
  }, {
    key: "hoursToMs",
    value: function hoursToMs(hours) {
      return this.minutesToMs(hours * 60);
    }
  }, {
    key: "minutesToMs",
    value: function minutesToMs(minutes) {
      return minutes * 6 * 10 * 1000;
    }
  }, {
    key: "secondsToMs",
    value: function secondsToMs(seconds) {
      return seconds * 1000;
    }
  }]);
  return DateUtils;
}();

/**
 * Inspired by https://dev.to/tipsy_dev/advanced-typescript-reinventing-lodash-get-4fhe
 */
function get(data, path, defaultValue) {
  var lodashPath = path.split('.');
  return lodashGet(data, lodashPath, defaultValue);
}

function getID() {
  return v4();
}

/**
 * A `Success<T, E>` represents a successful computation that returns a value of type `T`.
 *
 * `E` in `Success<T, E>` is the type of the error that would have been returned in case of failure.
 * It's present only to allow type safety of the `isFailure` method.
 *
 * @sealed
 * @privateRemarks DO NOT EXPORT, see type export later on
 */
var Success = /*#__PURE__*/function () {
  /** @internal */
  function Success(value) {
    _classCallCheck(this, Success);
    this.value = value;
  }
  _createClass(Success, [{
    key: "isSuccess",
    value: function isSuccess() {
      return true;
    }
  }, {
    key: "isFailure",
    value: function isFailure() {
      return false;
    }
  }, {
    key: "unwrap",
    value: function unwrap() {
      return this.value;
    }
  }]);
  return Success;
}();
/**
 * A `Success<T, E>` represents a successful computation that returns a value of type `T`.
 *
 * `T` in `Failure<T, E>` is the type of the value that would have been returned in case of success.
 * It's present only to allow type safety of the `isSuccess` method.
 *
 * @sealed
 * @privateRemarks DO NOT EXPORT, see type export later on
 */
var Failure = /*#__PURE__*/function () {
  /** @internal */
  function Failure(error) {
    _classCallCheck(this, Failure);
    this.error = error;
  }
  _createClass(Failure, [{
    key: "isSuccess",
    value: function isSuccess() {
      return false;
    }
  }, {
    key: "isFailure",
    value: function isFailure() {
      return true;
    }
  }, {
    key: "unwrap",
    value: function unwrap() {
      throw this.error;
    }
  }]);
  return Failure;
}();
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function success() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  return new Success(value);
}
var failure = function failure(error) {
  return new Failure(error);
};

/**
 * Returns `true` if the result is a success.
 */
function assertSuccess(result) {
  invariant(result.isSuccess(), 'Expected a success result');
}

/**
 * Returns `true` if the result is a failure.
 */
function assertFailure(result) {
  invariant(result.isFailure(), 'Expected a failure result');
}

/**
 * Unwraps the promise to allow resolving/rejecting outside the Promise constructor
 */
var Deferred = /*#__PURE__*/_createClass(function Deferred() {
  var _this = this;
  _classCallCheck(this, Deferred);
  this.promise = new Promise(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
  });
});

var POLLING_TIME = 1000;
var lastActiveTimerId = 0;
var activeTimers = new Set();
var safeSetTimeoutRec = function safeSetTimeoutRec(fn, endTime, timerId, options) {
  var msToEnd = endTime - Date.now();
  setTimeout(function () {
    if (!activeTimers.has(timerId)) {
      return;
    }
    var now = Date.now();
    if (now >= endTime) {
      activeTimers["delete"](timerId);
      fn();
    } else {
      safeSetTimeoutRec(fn, endTime, timerId, options);
    }
  }, msToEnd <= options.poolingTimeout ? msToEnd : options.poolingTimeout);
};

/**
 * Safe version of `setTimeout` that should support
 * 1. Large milliseconds delays (larger than 2147483647)
 * 2. Hibernation/Sleep
 *
 * @param fn - callback to be invoked after
 * @param ms - milliseconds to wait
 * @param options - timer options
 *
 * Note: `safeSetTimeout` should be only used when really needed
 *        as processor overhead is bigger than with normal `setTimeout`
 * @returns timerId Use `clearSafeTimeout(timerId)` to cancel timeout
 */
var safeSetTimeout = function safeSetTimeout(fn, ms) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    poolingTimeout: POLLING_TIME
  };
  var timerId = ++lastActiveTimerId;
  activeTimers.add(timerId);
  safeSetTimeoutRec(fn, Date.now() + ms, timerId, options);
  return timerId;
};

/**
 * Cancel timeout created with `safeSetTimeout`.
 */
var clearSafeTimeout = function clearSafeTimeout(timerId) {
  activeTimers["delete"](timerId);
};

function assertError(error) {
  if (!(error instanceof Error)) {
    throw new InvariantError("Invalid error type. Received ".concat(_typeof(error), ", expected instance of Error"));
  }
}
function assertErrorWithCode(error) {
  // eslint-disable-next-line no-prototype-builtins
  if (!(error instanceof Error && error.hasOwnProperty('code'))) {
    throw error;
  }
}
function assertErrorWithReason(error) {
  // eslint-disable-next-line no-prototype-builtins
  if (!(error instanceof Error && error.hasOwnProperty('reason'))) {
    throw error;
  }
}

/**
 * Exhaustiveness checking for union and enum types
 * see https://www.typescriptlang.org/docs/handbook/2/narrowing.html#exhaustiveness-checking
 */
function assertNever(x) {
  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected object: ".concat(String(x));
  throw new InvariantError(message);
}

function never() {
  var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Unexpected call to never()';
  throw new InvariantError(message);
}

/**
 *  Cast a `value` to exclude `null` and `undefined`.
 *  Throws if either `null` or `undefined` was passed
 */
function nonNullable(value, message) {
  if (value !== undefined && value !== null) {
    return value;
  }
  throw new InvariantError("Non nullable values expected, received ".concat(String(value), " with message: ").concat(message));
}
function isNonNullable(value) {
  return value !== null && value !== undefined;
}

var isInEnum = function isInEnum(enumVariables, value) {
  return Object.values(enumVariables).includes(value);
};

/* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any */
function isPrimitive(value) {
  return !isObjectLike(value);
}
function omitDeep(target, omitKey) {
  if (isPrimitive(target)) {
    return target;
  }
  if (Array.isArray(target)) {
    return target.map(function (item) {
      return omitDeep(item, omitKey);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
  return Object.keys(target).reduce(function (acc, key) {
    if (key === omitKey) {
      return acc;
    }
    var value = omitDeep(target[key], omitKey);
    acc[key] = value;
    return acc;
  }, {});
}

function maybe(thunk) {
  try {
    return thunk();
  } catch (_unused) {
    /* empty on purpose */
    return undefined;
  }
}

export { CausedError, DateUtils, Deferred, assertError, assertErrorWithCode, assertErrorWithReason, assertFailure, assertJustOne, assertNever, assertNonEmptyArray, assertSuccess, clearSafeTimeout, failure, get, getID, hasAtLeastOne, hasJustOne, hasTwoOrMore, isInEnum, isNonNullable, maybe, never, nonNullable, omitDeep, removeAtIndex, safeSetTimeout, success };
